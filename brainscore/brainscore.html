<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>langbrainscore.brainscore.brainscore API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>langbrainscore.brainscore.brainscore</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import typing

import numpy as np
import xarray as xr
from tqdm.auto import tqdm

# from methodtools import lru_cache
from pathlib import Path

from langbrainscore.interface import (
    _BrainScore,
    _Mapping,
    _Metric,
    EncoderRepresentations,
)

# from langbrainscore.metrics import Metric
from langbrainscore.utils import logging
from langbrainscore.utils.xarray import collapse_multidim_coord, copy_metadata


class BrainScore(_BrainScore):
    scores = None
    ceilings = None
    nulls = []

    def __init__(
        self,
        X: typing.Union[xr.DataArray, EncoderRepresentations],
        Y: typing.Union[xr.DataArray, EncoderRepresentations],
        mapping: _Mapping,
        metric: _Metric,
        sample_split_coord: str = None,
        neuroid_split_coord: str = None,
        run=False,
    ) -&gt; &#34;BrainScore&#34;:
        &#34;&#34;&#34;Initializes the [lang]BrainScore object using two encoded representations and a mapping
           class, and a metric for evaluation

        Args:
            X (typing.Union[xr.DataArray, EncoderRepresentations]): Either an xarray DataArray
                instance, or a wrapper object with a `.representations` attribute that stores the xarray
                DataArray
            Y (typing.Union[xr.DataArray, EncoderRepresentations]): see `X`
            mapping (_Mapping): _description_
            metric (_Metric): _description_
            run (bool, optional): _description_. Defaults to False.

        Returns:
            BrainScore: _description_
        &#34;&#34;&#34;
        self.X = X.representations if hasattr(X, &#34;representations&#34;) else X
        self.Y = Y.representations if hasattr(Y, &#34;representations&#34;) else Y
        assert self.X.sampleid.size == self.Y.sampleid.size
        self.mapping = mapping
        self.metric = metric
        self._sample_split_coord = sample_split_coord
        self._neuroid_split_coord = neuroid_split_coord

        if run:
            self.run()

    def __str__(self) -&gt; str:
        try:
            return f&#34;{self.scores.mean()}&#34;
        except AttributeError as e:
            raise ValueError(
                &#34;missing scores. did you make a call to `score()` or `run()` yet?&#34;
            )

    def to_netcdf(self, filename):
        &#34;&#34;&#34;
        outputs the xarray.DataArray object for &#39;scores&#39; to a netCDF file
        identified by `filename`. if it already exists, overwrites it.
        &#34;&#34;&#34;
        if Path(filename).expanduser().resolve().exists():
            logging.log(f&#34;{filename} already exists. overwriting.&#34;, type=&#34;WARN&#34;)
        self.scores.to_netcdf(filename)

    def load_netcdf(self, filename):
        &#34;&#34;&#34;
        loads a netCDF object that contains an xarray instance for &#39;scores&#39; from
        a file at `filename`.
        &#34;&#34;&#34;
        self.scores = xr.load_dataarray(filename)

    @staticmethod
    def _score(A, B, metric: _Metric) -&gt; np.ndarray:
        return metric(A, B)

    # @lru_cache(maxsize=None)
    def score(
        self,
        ceiling=False,
        null=False,
        seed=0,
    ):
        &#34;&#34;&#34;
        Computes The BrainScore™ (/s) using predictions/outputs returned by a
        Mapping instance which is a member attribute of a BrainScore instance
        &#34;&#34;&#34;
        assert not (ceiling and null)
        sample_split_coord = self._sample_split_coord
        neuroid_split_coord = self._neuroid_split_coord

        if sample_split_coord:
            assert sample_split_coord in self.Y.coords

        if neuroid_split_coord:
            assert neuroid_split_coord in self.Y.coords

        X = self.X
        if null:
            y_shuffle = self.Y.copy()
            y_shuffle.data = np.random.default_rng(seed=seed).permutation(
                y_shuffle.data, axis=0
            )
            Y = y_shuffle
        else:
            Y = self.Y
        y_pred, y_true = self.mapping.fit_transform(X, Y, ceiling=ceiling)

        if not (ceiling or null):
            self.Y_pred = y_pred
            if y_pred.shape == y_true.shape:  # not IdentityMap
                self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;sampleid&#34;)
                self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;neuroid&#34;)
                self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;timeid&#34;)

        scores_over_time = []
        for timeid in y_true.timeid.values:

            y_pred_time = y_pred.sel(timeid=timeid).transpose(&#34;sampleid&#34;, &#34;neuroid&#34;)
            y_true_time = y_true.sel(timeid=timeid).transpose(&#34;sampleid&#34;, &#34;neuroid&#34;)

            if sample_split_coord:
                if sample_split_coord not in y_true_time.sampleid.coords:
                    y_pred_time = collapse_multidim_coord(
                        y_pred_time, sample_split_coord, &#34;sampleid&#34;
                    )
                    y_true_time = collapse_multidim_coord(
                        y_true_time, sample_split_coord, &#34;sampleid&#34;
                    )
                score_splits = y_pred_time.sampleid.groupby(sample_split_coord).groups
            else:
                score_splits = [0]

            scores_over_time_group = []
            for scoreid in score_splits:

                if sample_split_coord:
                    y_pred_time_group = y_pred_time.isel(
                        sampleid=y_pred_time[sample_split_coord] == scoreid
                    )
                    y_true_time_group = y_true_time.isel(
                        sampleid=y_true_time[sample_split_coord] == scoreid
                    )
                else:
                    y_pred_time_group = y_pred_time
                    y_true_time_group = y_true_time

                neuroids = []
                if y_pred.shape != y_true.shape and neuroid_split_coord:  # IdentityMap
                    if neuroid_split_coord:
                        if neuroid_split_coord not in y_true_time_group.neuroid.coords:
                            y_true_time_group = collapse_multidim_coord(
                                y_true_time_group, neuroid_split_coord, &#34;neuroid&#34;
                            )
                        neuroid_splits = y_true_time_group.neuroid.groupby(
                            neuroid_split_coord
                        ).groups
                        score_per_time_group = []
                        for neuroid in neuroid_splits:
                            score_per_time_group.append(
                                self._score(
                                    y_pred_time_group,
                                    y_true_time_group.isel(
                                        neuroid=(
                                            y_true_time_group[neuroid_split_coord]
                                            == neuroid
                                        )
                                    ),
                                    self.metric,
                                )
                            )
                            neuroids.append(neuroid)
                        score_per_time_group = np.array(score_per_time_group)
                else:
                    score_per_time_group = self._score(
                        y_pred_time_group, y_true_time_group, self.metric
                    )

                if neuroids:
                    pass
                elif len(score_per_time_group) == 1:  # e.g., RSA, CKA, w/o split
                    neuroids = [np.nan]
                else:
                    neuroids = y_true_time_group.neuroid.data

                scores_over_time_group.append(
                    xr.DataArray(
                        score_per_time_group.reshape(1, -1, 1),
                        dims=(&#34;scoreid&#34;, &#34;neuroid&#34;, &#34;timeid&#34;),
                        coords={
                            &#34;scoreid&#34;: (&#34;scoreid&#34;, [scoreid]),
                            &#34;neuroid&#34;: (&#34;neuroid&#34;, neuroids),
                            &#34;timeid&#34;: (&#34;timeid&#34;, [timeid]),
                        },
                    )
                )

            scores_over_time.append(xr.concat(scores_over_time_group, dim=&#34;scoreid&#34;))

        scores = xr.concat(scores_over_time, dim=&#34;timeid&#34;)

        if scores.neuroid.size == self.Y.neuroid.size:  # not RSA, CKA, etc.
            scores = copy_metadata(scores, self.Y, &#34;neuroid&#34;)
        scores = copy_metadata(scores, self.Y, &#34;timeid&#34;)

        if not (ceiling or null):
            self.scores = scores
        elif ceiling:
            self.ceilings = scores
        else:
            self.nulls.append(
                scores.expand_dims(dim={&#34;iter&#34;: [seed]}, axis=-1).assign_coords(
                    iter=[seed]
                )
            )

    def ceiling(self):  # , sample_split_coord=None, neuroid_split_coord=None):
        logging.log(&#34;Calculating ceiling.&#34;, type=&#34;INFO&#34;)
        self.score(
            ceiling=True,
            # sample_split_coord=self._sample_split_coord,
            # neuroid_split_coord=neuroid_split_coord,
        )

    def null(
        self,
        # sample_split_coord=None, neuroid_split_coord=None,
        iters=100,
    ):
        for i in tqdm([*range(iters)], desc=&#34;Running null permutations&#34;):
            self.score(
                null=True,
                # sample_split_coord=sample_split_coord,
                # neuroid_split_coord=neuroid_split_coord,
                seed=i,
            )
        self.nulls = xr.concat(self.nulls, dim=&#34;iter&#34;)

    def run(
        self,
        sample_split_coord=None,
        neuroid_split_coord=None,
        calc_nulls=False,
        iters=100,
    ):
        self.score(
            sample_split_coord=sample_split_coord,
            neuroid_split_coord=neuroid_split_coord,
        )
        self.ceiling(
            sample_split_coord=sample_split_coord,
            neuroid_split_coord=neuroid_split_coord,
        )
        if calc_nulls:
            self.null(
                sample_split_coord=sample_split_coord,
                neuroid_split_coord=neuroid_split_coord,
                iters=iters,
            )
            return {
                &#34;scores&#34;: self.scores,
                &#34;ceilings&#34;: self.ceilings,
                &#34;nulls&#34;: self.nulls,
            }
        return {&#34;scores&#34;: self.scores, &#34;ceilings&#34;: self.ceilings}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="langbrainscore.brainscore.brainscore.BrainScore"><code class="flex name class">
<span>class <span class="ident">BrainScore</span></span>
<span>(</span><span>X: Union[xarray.core.dataarray.DataArray, <a title="langbrainscore.interface.encoder.EncoderRepresentations" href="../interface/encoder.html#langbrainscore.interface.encoder.EncoderRepresentations">EncoderRepresentations</a>], Y: Union[xarray.core.dataarray.DataArray, <a title="langbrainscore.interface.encoder.EncoderRepresentations" href="../interface/encoder.html#langbrainscore.interface.encoder.EncoderRepresentations">EncoderRepresentations</a>], mapping: langbrainscore.interface.mapping._Mapping, metric: langbrainscore.interface.metric._Metric, sample_split_coord: str = None, neuroid_split_coord: str = None, run=False)</span>
</code></dt>
<dd>
<div class="desc"><p>evaluates a <code>Mapping</code> of <code>X</code> and <code>Y</code> using <code>Metric</code></p>
<p>Initializes the [lang]BrainScore object using two encoded representations and a mapping
class, and a metric for evaluation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>typing.Union[xr.DataArray, EncoderRepresentations]</code></dt>
<dd>Either an xarray DataArray
instance, or a wrapper object with a <code>.representations</code> attribute that stores the xarray
DataArray</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>typing.Union[xr.DataArray, EncoderRepresentations]</code></dt>
<dd>see <code>X</code></dd>
<dt><strong><code>mapping</code></strong> :&ensp;<code>_Mapping</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>_Metric</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>run</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="langbrainscore.brainscore.brainscore.BrainScore" href="#langbrainscore.brainscore.brainscore.BrainScore">BrainScore</a></code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BrainScore(_BrainScore):
    scores = None
    ceilings = None
    nulls = []

    def __init__(
        self,
        X: typing.Union[xr.DataArray, EncoderRepresentations],
        Y: typing.Union[xr.DataArray, EncoderRepresentations],
        mapping: _Mapping,
        metric: _Metric,
        sample_split_coord: str = None,
        neuroid_split_coord: str = None,
        run=False,
    ) -&gt; &#34;BrainScore&#34;:
        &#34;&#34;&#34;Initializes the [lang]BrainScore object using two encoded representations and a mapping
           class, and a metric for evaluation

        Args:
            X (typing.Union[xr.DataArray, EncoderRepresentations]): Either an xarray DataArray
                instance, or a wrapper object with a `.representations` attribute that stores the xarray
                DataArray
            Y (typing.Union[xr.DataArray, EncoderRepresentations]): see `X`
            mapping (_Mapping): _description_
            metric (_Metric): _description_
            run (bool, optional): _description_. Defaults to False.

        Returns:
            BrainScore: _description_
        &#34;&#34;&#34;
        self.X = X.representations if hasattr(X, &#34;representations&#34;) else X
        self.Y = Y.representations if hasattr(Y, &#34;representations&#34;) else Y
        assert self.X.sampleid.size == self.Y.sampleid.size
        self.mapping = mapping
        self.metric = metric
        self._sample_split_coord = sample_split_coord
        self._neuroid_split_coord = neuroid_split_coord

        if run:
            self.run()

    def __str__(self) -&gt; str:
        try:
            return f&#34;{self.scores.mean()}&#34;
        except AttributeError as e:
            raise ValueError(
                &#34;missing scores. did you make a call to `score()` or `run()` yet?&#34;
            )

    def to_netcdf(self, filename):
        &#34;&#34;&#34;
        outputs the xarray.DataArray object for &#39;scores&#39; to a netCDF file
        identified by `filename`. if it already exists, overwrites it.
        &#34;&#34;&#34;
        if Path(filename).expanduser().resolve().exists():
            logging.log(f&#34;{filename} already exists. overwriting.&#34;, type=&#34;WARN&#34;)
        self.scores.to_netcdf(filename)

    def load_netcdf(self, filename):
        &#34;&#34;&#34;
        loads a netCDF object that contains an xarray instance for &#39;scores&#39; from
        a file at `filename`.
        &#34;&#34;&#34;
        self.scores = xr.load_dataarray(filename)

    @staticmethod
    def _score(A, B, metric: _Metric) -&gt; np.ndarray:
        return metric(A, B)

    # @lru_cache(maxsize=None)
    def score(
        self,
        ceiling=False,
        null=False,
        seed=0,
    ):
        &#34;&#34;&#34;
        Computes The BrainScore™ (/s) using predictions/outputs returned by a
        Mapping instance which is a member attribute of a BrainScore instance
        &#34;&#34;&#34;
        assert not (ceiling and null)
        sample_split_coord = self._sample_split_coord
        neuroid_split_coord = self._neuroid_split_coord

        if sample_split_coord:
            assert sample_split_coord in self.Y.coords

        if neuroid_split_coord:
            assert neuroid_split_coord in self.Y.coords

        X = self.X
        if null:
            y_shuffle = self.Y.copy()
            y_shuffle.data = np.random.default_rng(seed=seed).permutation(
                y_shuffle.data, axis=0
            )
            Y = y_shuffle
        else:
            Y = self.Y
        y_pred, y_true = self.mapping.fit_transform(X, Y, ceiling=ceiling)

        if not (ceiling or null):
            self.Y_pred = y_pred
            if y_pred.shape == y_true.shape:  # not IdentityMap
                self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;sampleid&#34;)
                self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;neuroid&#34;)
                self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;timeid&#34;)

        scores_over_time = []
        for timeid in y_true.timeid.values:

            y_pred_time = y_pred.sel(timeid=timeid).transpose(&#34;sampleid&#34;, &#34;neuroid&#34;)
            y_true_time = y_true.sel(timeid=timeid).transpose(&#34;sampleid&#34;, &#34;neuroid&#34;)

            if sample_split_coord:
                if sample_split_coord not in y_true_time.sampleid.coords:
                    y_pred_time = collapse_multidim_coord(
                        y_pred_time, sample_split_coord, &#34;sampleid&#34;
                    )
                    y_true_time = collapse_multidim_coord(
                        y_true_time, sample_split_coord, &#34;sampleid&#34;
                    )
                score_splits = y_pred_time.sampleid.groupby(sample_split_coord).groups
            else:
                score_splits = [0]

            scores_over_time_group = []
            for scoreid in score_splits:

                if sample_split_coord:
                    y_pred_time_group = y_pred_time.isel(
                        sampleid=y_pred_time[sample_split_coord] == scoreid
                    )
                    y_true_time_group = y_true_time.isel(
                        sampleid=y_true_time[sample_split_coord] == scoreid
                    )
                else:
                    y_pred_time_group = y_pred_time
                    y_true_time_group = y_true_time

                neuroids = []
                if y_pred.shape != y_true.shape and neuroid_split_coord:  # IdentityMap
                    if neuroid_split_coord:
                        if neuroid_split_coord not in y_true_time_group.neuroid.coords:
                            y_true_time_group = collapse_multidim_coord(
                                y_true_time_group, neuroid_split_coord, &#34;neuroid&#34;
                            )
                        neuroid_splits = y_true_time_group.neuroid.groupby(
                            neuroid_split_coord
                        ).groups
                        score_per_time_group = []
                        for neuroid in neuroid_splits:
                            score_per_time_group.append(
                                self._score(
                                    y_pred_time_group,
                                    y_true_time_group.isel(
                                        neuroid=(
                                            y_true_time_group[neuroid_split_coord]
                                            == neuroid
                                        )
                                    ),
                                    self.metric,
                                )
                            )
                            neuroids.append(neuroid)
                        score_per_time_group = np.array(score_per_time_group)
                else:
                    score_per_time_group = self._score(
                        y_pred_time_group, y_true_time_group, self.metric
                    )

                if neuroids:
                    pass
                elif len(score_per_time_group) == 1:  # e.g., RSA, CKA, w/o split
                    neuroids = [np.nan]
                else:
                    neuroids = y_true_time_group.neuroid.data

                scores_over_time_group.append(
                    xr.DataArray(
                        score_per_time_group.reshape(1, -1, 1),
                        dims=(&#34;scoreid&#34;, &#34;neuroid&#34;, &#34;timeid&#34;),
                        coords={
                            &#34;scoreid&#34;: (&#34;scoreid&#34;, [scoreid]),
                            &#34;neuroid&#34;: (&#34;neuroid&#34;, neuroids),
                            &#34;timeid&#34;: (&#34;timeid&#34;, [timeid]),
                        },
                    )
                )

            scores_over_time.append(xr.concat(scores_over_time_group, dim=&#34;scoreid&#34;))

        scores = xr.concat(scores_over_time, dim=&#34;timeid&#34;)

        if scores.neuroid.size == self.Y.neuroid.size:  # not RSA, CKA, etc.
            scores = copy_metadata(scores, self.Y, &#34;neuroid&#34;)
        scores = copy_metadata(scores, self.Y, &#34;timeid&#34;)

        if not (ceiling or null):
            self.scores = scores
        elif ceiling:
            self.ceilings = scores
        else:
            self.nulls.append(
                scores.expand_dims(dim={&#34;iter&#34;: [seed]}, axis=-1).assign_coords(
                    iter=[seed]
                )
            )

    def ceiling(self):  # , sample_split_coord=None, neuroid_split_coord=None):
        logging.log(&#34;Calculating ceiling.&#34;, type=&#34;INFO&#34;)
        self.score(
            ceiling=True,
            # sample_split_coord=self._sample_split_coord,
            # neuroid_split_coord=neuroid_split_coord,
        )

    def null(
        self,
        # sample_split_coord=None, neuroid_split_coord=None,
        iters=100,
    ):
        for i in tqdm([*range(iters)], desc=&#34;Running null permutations&#34;):
            self.score(
                null=True,
                # sample_split_coord=sample_split_coord,
                # neuroid_split_coord=neuroid_split_coord,
                seed=i,
            )
        self.nulls = xr.concat(self.nulls, dim=&#34;iter&#34;)

    def run(
        self,
        sample_split_coord=None,
        neuroid_split_coord=None,
        calc_nulls=False,
        iters=100,
    ):
        self.score(
            sample_split_coord=sample_split_coord,
            neuroid_split_coord=neuroid_split_coord,
        )
        self.ceiling(
            sample_split_coord=sample_split_coord,
            neuroid_split_coord=neuroid_split_coord,
        )
        if calc_nulls:
            self.null(
                sample_split_coord=sample_split_coord,
                neuroid_split_coord=neuroid_split_coord,
                iters=iters,
            )
            return {
                &#34;scores&#34;: self.scores,
                &#34;ceilings&#34;: self.ceilings,
                &#34;nulls&#34;: self.nulls,
            }
        return {&#34;scores&#34;: self.scores, &#34;ceilings&#34;: self.ceilings}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>langbrainscore.interface.brainscore._BrainScore</li>
<li>langbrainscore.interface.cacheable._Cacheable</li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.ceilings"><code class="name">var <span class="ident">ceilings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.nulls"><code class="name">var <span class="ident">nulls</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.scores"><code class="name">var <span class="ident">scores</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.ceiling"><code class="name flex">
<span>def <span class="ident">ceiling</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ceiling(self):  # , sample_split_coord=None, neuroid_split_coord=None):
    logging.log(&#34;Calculating ceiling.&#34;, type=&#34;INFO&#34;)
    self.score(
        ceiling=True,
        # sample_split_coord=self._sample_split_coord,
        # neuroid_split_coord=neuroid_split_coord,
    )</code></pre>
</details>
</dd>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.load_netcdf"><code class="name flex">
<span>def <span class="ident">load_netcdf</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>loads a netCDF object that contains an xarray instance for 'scores' from
a file at <code>filename</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_netcdf(self, filename):
    &#34;&#34;&#34;
    loads a netCDF object that contains an xarray instance for &#39;scores&#39; from
    a file at `filename`.
    &#34;&#34;&#34;
    self.scores = xr.load_dataarray(filename)</code></pre>
</details>
</dd>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.null"><code class="name flex">
<span>def <span class="ident">null</span></span>(<span>self, iters=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def null(
    self,
    # sample_split_coord=None, neuroid_split_coord=None,
    iters=100,
):
    for i in tqdm([*range(iters)], desc=&#34;Running null permutations&#34;):
        self.score(
            null=True,
            # sample_split_coord=sample_split_coord,
            # neuroid_split_coord=neuroid_split_coord,
            seed=i,
        )
    self.nulls = xr.concat(self.nulls, dim=&#34;iter&#34;)</code></pre>
</details>
</dd>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, sample_split_coord=None, neuroid_split_coord=None, calc_nulls=False, iters=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
    self,
    sample_split_coord=None,
    neuroid_split_coord=None,
    calc_nulls=False,
    iters=100,
):
    self.score(
        sample_split_coord=sample_split_coord,
        neuroid_split_coord=neuroid_split_coord,
    )
    self.ceiling(
        sample_split_coord=sample_split_coord,
        neuroid_split_coord=neuroid_split_coord,
    )
    if calc_nulls:
        self.null(
            sample_split_coord=sample_split_coord,
            neuroid_split_coord=neuroid_split_coord,
            iters=iters,
        )
        return {
            &#34;scores&#34;: self.scores,
            &#34;ceilings&#34;: self.ceilings,
            &#34;nulls&#34;: self.nulls,
        }
    return {&#34;scores&#34;: self.scores, &#34;ceilings&#34;: self.ceilings}</code></pre>
</details>
</dd>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.score"><code class="name flex">
<span>def <span class="ident">score</span></span>(<span>self, ceiling=False, null=False, seed=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes The BrainScore™ (/s) using predictions/outputs returned by a
Mapping instance which is a member attribute of a BrainScore instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score(
    self,
    ceiling=False,
    null=False,
    seed=0,
):
    &#34;&#34;&#34;
    Computes The BrainScore™ (/s) using predictions/outputs returned by a
    Mapping instance which is a member attribute of a BrainScore instance
    &#34;&#34;&#34;
    assert not (ceiling and null)
    sample_split_coord = self._sample_split_coord
    neuroid_split_coord = self._neuroid_split_coord

    if sample_split_coord:
        assert sample_split_coord in self.Y.coords

    if neuroid_split_coord:
        assert neuroid_split_coord in self.Y.coords

    X = self.X
    if null:
        y_shuffle = self.Y.copy()
        y_shuffle.data = np.random.default_rng(seed=seed).permutation(
            y_shuffle.data, axis=0
        )
        Y = y_shuffle
    else:
        Y = self.Y
    y_pred, y_true = self.mapping.fit_transform(X, Y, ceiling=ceiling)

    if not (ceiling or null):
        self.Y_pred = y_pred
        if y_pred.shape == y_true.shape:  # not IdentityMap
            self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;sampleid&#34;)
            self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;neuroid&#34;)
            self.Y_pred = copy_metadata(self.Y_pred, self.Y, &#34;timeid&#34;)

    scores_over_time = []
    for timeid in y_true.timeid.values:

        y_pred_time = y_pred.sel(timeid=timeid).transpose(&#34;sampleid&#34;, &#34;neuroid&#34;)
        y_true_time = y_true.sel(timeid=timeid).transpose(&#34;sampleid&#34;, &#34;neuroid&#34;)

        if sample_split_coord:
            if sample_split_coord not in y_true_time.sampleid.coords:
                y_pred_time = collapse_multidim_coord(
                    y_pred_time, sample_split_coord, &#34;sampleid&#34;
                )
                y_true_time = collapse_multidim_coord(
                    y_true_time, sample_split_coord, &#34;sampleid&#34;
                )
            score_splits = y_pred_time.sampleid.groupby(sample_split_coord).groups
        else:
            score_splits = [0]

        scores_over_time_group = []
        for scoreid in score_splits:

            if sample_split_coord:
                y_pred_time_group = y_pred_time.isel(
                    sampleid=y_pred_time[sample_split_coord] == scoreid
                )
                y_true_time_group = y_true_time.isel(
                    sampleid=y_true_time[sample_split_coord] == scoreid
                )
            else:
                y_pred_time_group = y_pred_time
                y_true_time_group = y_true_time

            neuroids = []
            if y_pred.shape != y_true.shape and neuroid_split_coord:  # IdentityMap
                if neuroid_split_coord:
                    if neuroid_split_coord not in y_true_time_group.neuroid.coords:
                        y_true_time_group = collapse_multidim_coord(
                            y_true_time_group, neuroid_split_coord, &#34;neuroid&#34;
                        )
                    neuroid_splits = y_true_time_group.neuroid.groupby(
                        neuroid_split_coord
                    ).groups
                    score_per_time_group = []
                    for neuroid in neuroid_splits:
                        score_per_time_group.append(
                            self._score(
                                y_pred_time_group,
                                y_true_time_group.isel(
                                    neuroid=(
                                        y_true_time_group[neuroid_split_coord]
                                        == neuroid
                                    )
                                ),
                                self.metric,
                            )
                        )
                        neuroids.append(neuroid)
                    score_per_time_group = np.array(score_per_time_group)
            else:
                score_per_time_group = self._score(
                    y_pred_time_group, y_true_time_group, self.metric
                )

            if neuroids:
                pass
            elif len(score_per_time_group) == 1:  # e.g., RSA, CKA, w/o split
                neuroids = [np.nan]
            else:
                neuroids = y_true_time_group.neuroid.data

            scores_over_time_group.append(
                xr.DataArray(
                    score_per_time_group.reshape(1, -1, 1),
                    dims=(&#34;scoreid&#34;, &#34;neuroid&#34;, &#34;timeid&#34;),
                    coords={
                        &#34;scoreid&#34;: (&#34;scoreid&#34;, [scoreid]),
                        &#34;neuroid&#34;: (&#34;neuroid&#34;, neuroids),
                        &#34;timeid&#34;: (&#34;timeid&#34;, [timeid]),
                    },
                )
            )

        scores_over_time.append(xr.concat(scores_over_time_group, dim=&#34;scoreid&#34;))

    scores = xr.concat(scores_over_time, dim=&#34;timeid&#34;)

    if scores.neuroid.size == self.Y.neuroid.size:  # not RSA, CKA, etc.
        scores = copy_metadata(scores, self.Y, &#34;neuroid&#34;)
    scores = copy_metadata(scores, self.Y, &#34;timeid&#34;)

    if not (ceiling or null):
        self.scores = scores
    elif ceiling:
        self.ceilings = scores
    else:
        self.nulls.append(
            scores.expand_dims(dim={&#34;iter&#34;: [seed]}, axis=-1).assign_coords(
                iter=[seed]
            )
        )</code></pre>
</details>
</dd>
<dt id="langbrainscore.brainscore.brainscore.BrainScore.to_netcdf"><code class="name flex">
<span>def <span class="ident">to_netcdf</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>outputs the xarray.DataArray object for 'scores' to a netCDF file
identified by <code>filename</code>. if it already exists, overwrites it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_netcdf(self, filename):
    &#34;&#34;&#34;
    outputs the xarray.DataArray object for &#39;scores&#39; to a netCDF file
    identified by `filename`. if it already exists, overwrites it.
    &#34;&#34;&#34;
    if Path(filename).expanduser().resolve().exists():
        logging.log(f&#34;{filename} already exists. overwriting.&#34;, type=&#34;WARN&#34;)
    self.scores.to_netcdf(filename)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="langbrainscore.brainscore" href="index.html">langbrainscore.brainscore</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="langbrainscore.brainscore.brainscore.BrainScore" href="#langbrainscore.brainscore.brainscore.BrainScore">BrainScore</a></code></h4>
<ul class="two-column">
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.ceiling" href="#langbrainscore.brainscore.brainscore.BrainScore.ceiling">ceiling</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.ceilings" href="#langbrainscore.brainscore.brainscore.BrainScore.ceilings">ceilings</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.load_netcdf" href="#langbrainscore.brainscore.brainscore.BrainScore.load_netcdf">load_netcdf</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.null" href="#langbrainscore.brainscore.brainscore.BrainScore.null">null</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.nulls" href="#langbrainscore.brainscore.brainscore.BrainScore.nulls">nulls</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.run" href="#langbrainscore.brainscore.brainscore.BrainScore.run">run</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.score" href="#langbrainscore.brainscore.brainscore.BrainScore.score">score</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.scores" href="#langbrainscore.brainscore.brainscore.BrainScore.scores">scores</a></code></li>
<li><code><a title="langbrainscore.brainscore.brainscore.BrainScore.to_netcdf" href="#langbrainscore.brainscore.brainscore.BrainScore.to_netcdf">to_netcdf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>